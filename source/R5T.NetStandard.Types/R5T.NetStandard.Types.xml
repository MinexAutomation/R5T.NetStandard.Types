<?xml version="1.0"?>
<doc>
    <assembly>
        <name>R5T.NetStandard.Types</name>
    </assembly>
    <members>
        <member name="T:R5T.NetStandard.Now">
            <summary>
            Operates in two modes: offset and absolute.
            Offset mode allows applying an offset to the current time to get a different now. This is useful for testing. For example, you can set the time to be January 1st, ask for Now.DateTime and then test whether the returned now is a holiday (which it will be). 
            Absolute mode allows setting the time for now. Until the specified time is changed, the same now will always be returned.
            </summary>
        </member>
        <member name="P:R5T.NetStandard.Now.Offset">
            <summary>
            The offset applied to the machine DateTime.Now to get get the Now.DateTime.
            </summary>
        </member>
        <member name="M:R5T.NetStandard.Now.SetNowLocal(System.DateTime)">
            <summary>
            Sets the offset such that right now is the specified now.
            </summary>
        </member>
        <member name="M:R5T.NetStandard.Now.ComputeOffset(System.DateTime)">
            <summary>
            Computes the offset from DateTime.Now to the specified now
            </summary>
        </member>
        <member name="P:R5T.NetStandard.Now.DateTime">
            <summary>
            Depending on the mode, either the machine DateTime.Now adjusted by the offset (offset), or the previously specified now (absolute).
            </summary>
        </member>
        <member name="P:R5T.NetStandard.Now.DateTimeUTC">
            <summary>
            Depending on the mode, either the machine DateTime.Now adjusted by the offset (offset), or the previously specified now (absolute).
            Converted from the machine timezone to the UTC +00:00 default timezone.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.TypedString">
            <summary>
            Allow wrapping a string with a specific type.
            This is helpful in creating strongly-typed strings for stringly-typed data. Examples: diretory path.
            </summary>
            <remarks>
            Many objects are "stringly-typed". For example, project name, project directory name, and project directory path are all strings, but are really different types of string.
            Creating methods that operate on these different types of string is clumsy. Because overloading is not possible (all methods take in the same argument type, string), methods must have different names.
            These extra names require more effort by the writer, but by the user, since they have to sort through the confusion caused by having multiple names for what is really the same operation being applied to different input types.
            The resolution to this difficulty is creating types that merely contain a string.
            This base type provides the actual functionality, inheritors just provide a name for their type of string.
            </remarks>
        </member>
        <member name="M:R5T.NetStandard.EnumHelper.GetUnrecognizedEnumerationValueMessage``1(System.String)">
            <summary>
            Gets a message indicating that the input string representation of an enumeration value was not recognized among the string representations of a possible values of the <typeparamref name="TEnum"/> enumeration.
            </summary>
        </member>
        <member name="M:R5T.NetStandard.EnumHelper.GetUnrecognizedEnumerationValueMessageLegacy``1(System.String)">
            <summary>
            Gets a message indicating that the input string representation of an enumeration value was not recognized among the string representations of a possible values of the <typeparamref name="TEnum"/> enumeration.
            Note: This legacy method that restricts <typeparamref name="TEnum"/> as a struct, instead of an <see cref="T:System.Enum"/>, is provided since <see cref="M:System.Enum.TryParse``1(System.String,``0@)"/> restricts on struct instead of <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:R5T.NetStandard.EnumHelper.Parse``1(System.String)">
            <summary>
            Parses the string representation of an enumeration value to an value of the <typeparamref name="TEnum"/> enumeration.
            Note: this method restricts <typeparamref name="TEnum"/> as a struct, instead of an <see cref="T:System.Enum"/>, since <see cref="M:System.Enum.TryParse``1(System.String,``0@)"/> restricts on struct instead of <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:R5T.NetStandard.EnumHelper.GetUnexpectedEnumerationValueMessage``1(``0)">
            <summary>
            Gets a message indicating the the input value of the <typeparamref name="TEnum"/> enumeration was unexpected.
            This is useful in producing an error in the default case for switch statements based on enumeration values.
            </summary>
            <remarks>
            See: https://stackoverflow.com/questions/13645149/what-is-the-correct-exception-to-throw-for-unhandled-enum-values
            </remarks>
        </member>
        <member name="M:R5T.NetStandard.EnumHelper.GetValues``1">
            <summary>
            Gets all values of the <typeparamref name="TEnum"/> enumeration.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IConsumer`1">
            <summary>
            Consumes instances of type <typeparamref name="T"/> for processing.
            Basically, an <see cref="T:System.Action`1"/> as a type, not a delegate.
            For functions see <see cref="T:R5T.NetStandard.IProvider`1"/>.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IConsumer`2">
            <summary>
            Consumes paired instances of types <typeparamref name="T1"/> and <typeparamref name="T2"/> for processing.
            Basically, an <see cref="T:System.Action`2"/> as a type, not a delegate.
            For functions see <see cref="T:R5T.NetStandard.IProvider`1"/>.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IConsumer`3">
            <summary>
            Consumes triplet instances of types <typeparamref name="T1"/>, <typeparamref name="T2"/>, and <typeparamref name="T3"/> for processing.
            Basically, an <see cref="T:System.Action`3"/> as a type, not a delegate.
            For functions see <see cref="T:R5T.NetStandard.IProvider`1"/>.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.INamed">
            <summary>
            Interface for types whose instances are named (have a name).
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IProvider`1">
            <summary>
            Provides an instance of a specified type.
            Basically, a <see cref="T:System.Func`1"/> as a type, not a delegate.
            For actions see <see cref="T:R5T.NetStandard.IConsumer`1"/>.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IProvider`2">
            <summary>
            Provides an instance of a specified output type, given an instance of a specified input type.
            Basically, a <see cref="T:System.Func`2"/> as a type, not a delegate.
            For actions see <see cref="T:R5T.NetStandard.IConsumer`1"/>.
            </summary>
        </member>
        <member name="T:R5T.NetStandard.IProvider`3">
            <summary>
            Provides an instance of a specified output type, given an instance of a specified input type.
            Basically, a <see cref="T:System.Func`3"/> as a type, not a delegate.
            For actions see <see cref="T:R5T.NetStandard.IConsumer`1"/>.
            </summary>
        </member>
    </members>
</doc>
